# Introduction to Testing

Testing is required to avoid bugs and flaws in the program
- A bug is an error/flaw/failure in the program that causes the program to behave unexpectedly

# Can We Test Everything?

Consider that we wanted to test the following function

```
int doSomething(int input) {
    return (input - 1) / 30000;
}
```

The function should do the following:
- Take an integer input value, add 1 to it, divide by 30000, and return the value

For a 16 bit integer, there are $2^{16}$ possible values. We can still test every possible value, however that is too costly.

We should strategically choose specific values that are likely to cause errors if the function is not correct, or inputs that cover a wide range of vales

- -1
- 0
- 32767
- -32767

# Black Box vs White Box Testing

Black box testing is a software testing method in which we do not know the implementation of the function, we only know how the function should behave
- Choose test cases that are likely to cause errors, or a range of test cases that cover a wide variety of input values

White box testing is a software testing method in which the internal structure of the function under test is known to the tester
- Usually tries to cover all statements, branches and execution paths

# Basis Path Testing

Basis Path Testing (or Structured testing) is a white box testing method used for designing test cases intended to examine all possible paths of execution in a program
- Analyse control flow graph
- Determines cyclomatic complexity of function under test (Refers to the number of linearly independent paths in the function. It is a measure of how complex a function is in regards to the number of possible paths)
- Obtains linearly independent paths
- Generates test cases for each path

# Objectives of Testing

- To show when **software does not work**
- To reduce the perceived risk of a system not working to an acceptable value
- To result in low-risk software without much testing efforts

# Types of Testing

1. Black box testing
    - Analyse the requirements and specifications of the function under test
    - E.g. "The income of an applicant should be between 1000 - 2000"
    - Types of black box testing include
        - Equivalence testing and boundary value testing
2. White box testing
    - Analyse implementation, internal paths and structure
    - Types of white box testing include
        - Control flow testing
        - Data flow testing

# Levels of Testing

1. Unit testing - Testing units individually
2. Integration testing - Test units in combination
3. System testing - Test everything (functionality, portability, usability, performance etc.)
4. Acceptance testing - Customer accepts the software and gives us money

# Components of a Test Case

1. Name: The distinct name of the test case
2. Location: Path to test program and its input
3. Input: Input data or commands
4. Oracle: Expected test output
5. Log: Actual output produced by the test

E.g. the test case for a mortgage calculator

| Income | Number of mortgages | Applicant Type | Property Type | Expected result | Test result |
| ------ | ------------------- | -------------- | ------------- | --------------- | ----------- |
| 5000   | 2                   | Person         | Cando         | Approval        | Approval    |
| 100    | 1                   | Person         | HDB           | Reject          | Reject      |
| 1501   | 8                   | Person         | Condo         | Reject          | Approval    |

# Order of Test Case Execution

Cascading test cases

1. Create order
2. Update order
3. Delete order
4. Read deleted order

- Smaller and simple test cases
- However if one fails, the other test cases may be invalid

Independent test cases
- Self contained test cases for the above features
- Parallel test execution
- However, larger and more complex test cases