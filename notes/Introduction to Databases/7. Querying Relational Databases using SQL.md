# Querying Relational Databases using SQL

# What is SQL

- Structured Query Language (SQL) is a standard query language for relational databases

# What can we do with SQL?

- Manage and query the database (a set of relations/tables)
- Retrieve
- Insert
- Delete
- Update

SQL is declarative
- A SQL query specifies what to retrieve, but not how to retrieve it (procedural)

# Functions Supported by SQL

Data Manipulation Language (DML)
- Perform queries
- Perform updates (add/delete/modify)

Data Definition Language (DDL)
- Creates databases, tables, indices
- Creates views
- Specify authorisation
- Specify integrity constraints

Embedded SQL
- Wrap a high-level programming language around DML to do more sophisticated queryies/updates

# Tables in SQL

A relation or table is a multiset of tuples having the attributes specified by the schema. 
- A multiset is an unordered list (or: a set with multiple duplicate instances allowed)

For example: 

| PName       | Price | Manufacturer |
| ----------- | ----- | ------------ |
| Gizmo       | 20    | GizmoWorks   |
| Powergizmo  | 30    | GizmoWorks   |
| SingleTouch | 150   | Canon        |
| MultiTouch  | 204   | Hitachi      |

## Attributes (Columns) in a Table

An attribute (or column) is a typed data entry present in each tuple in the relation
- Attributes must have an atomic type in sstandard SQL, i.e. not a list, set, etc.

## Tuples (Rows) in a Table

A tuple or row is a single entry in the table having the attributes specified by the schema
- Also referred to sometimes as a record

## More on Tables

- The number of tuples is the cardinality of the relation
- The number of attributes is the arity of the relation

# Data Types in SQL

Atomic types
- Characters: `CHAR(20)`, `VARCHAR(50)`
- Numbers: `INT`, `BIGINT`, `SMALLINT`, `FLOAT`
- Others: `MONEY`, `DATETIME`

Every attribute must have an atomic type
- Hence the tables are flat

# Schema of a Table

| PName       | Price | Manufacturer |
| ----------- | ----- | ------------ |
| Gizmo       | 20    | GizmoWorks   |
| Powergizmo  | 30    | GizmoWorks   |
| SingleTouch | 150   | Canon        |
| MultiTouch  | 204   | Hitachi      |

- The schema of table is the table name, its attributes, and their types:

```
Product(Pname: string, Price: float, Manufacturer: string)
```

- A key is an attribute whose values are unique; we underline a primary key

# Principle Form of SQL

Basic Structure of SQL

```
SELECT desired attributes (A1, A2, ..., An)
FROM one or more tables (R1, R2, ..., Rm)
WHERE condition about tuples of the tables (P)
```

Mapping to Relational Algebra

$$
\Pi_{A_1, A_2, ..., A_n} (\sigma_P (R_1 \times R_2 \times \cdot \times R_m))
$$

# SQL Syntax

## Reserved words/Keywords

- There is a set of reserved words that cannot be used as names for database objects
- `SELECT`, `FROM`, `WHERE`, etc.

## Case-insensitive

- SQL is generally case-insensitive
    - Exception: String constants are case sensitive ('FRED' vs 'fred')
- Use single quotes for constants
    - 'abc' is valid
    - "abc" is invalid
- White-space is ignored
- All statements end with a semicolon;

# Simple SQL Query: Selection

Selection is the operation of filtering a relation's tuples on some condition

```sql
SELECT *
FROM Product
WHERE Category = 'Gadgets';
```

This query selects all columns from the `Product` relation, where `Category = 'Gadgets'`

# Simple SQL Query: Projection

Projection is the operation of producing an output table with typles that have a subset of their prior attributes

```sql
SELECT PName, Price, Manufacturer
FROM Product
WHERE Category = 'Gadgets';
```

This query selects the specific columns: `PName`, `Price`, `Manufacturer` from the relation `Product`, where `Category = 'Gadgets'`

# `DISTINCT`: Eliminating Duplicates

```sql
SELECT DISTINCT Category 
FROM Product;
```

# `AS`: Renaming Attributes

```sql
SELECT PName AS Product, Price AS Cost, Manufacturer
FROM Product
WHERE Category = 'Gadgets'
```

# Expressions in `SELECT` Clause

```sql
SELECT PName, Price * 1.4 AS Cost_IN_SGD, Manufacturer
FROM Product
WHERE Category = 'Gadgets'
```

# Complex Conditions in `WHERE` Clause

## `AND`

Both sides of the `AND` condition must be true for the row to be selected

```sql
SELECT Pname, Price, Manufacturer
FROM Product
WHERE Category = 'Gadgets' AND Price < 20
```

## `BETWEEN`

Check if value of attribute must be between 2 values

```sql
SELECT PName, Price, Manufacturer
FROM Product
WHERE Price BETWEEN 10 AND 20
```

## `IN`

Check whether value is included in a collection

```sql
SELECT PName, Price, Manufacturer
FROM Product
WHERE Manufacturer IN ('GizmoWorks', 'Samsung', 'Hitachi')
```

## `LIKE` (String Pattern Matching)

`s LIKE p`: Pattern matching on strings. Patterns are case sensitive
- `p` may contain 2 special symbols
    - `%`: any sequence of characters
    - `_`: any single character

```sql
SELECT *
FROM Products
WHERE PName LIKE '%gizmo%';
```

This query selects all products where the `PName` contains the word `'gizmo'`

- `'John%'` - Matches any string beginning with "John"
- `'%ohn%' - Matches any string containing "ohn" as substring
- `'___'` - Matches any string with exactly 3 characters
- `'___%'` - Matches any string of at least 3 characters
- `'ab\%cd%'` - Matches all strings beginning with "ab%cd"

# `NULL` Values

Tuples in SQL relations can have `NULL` as value for one or more attributes. It means that a value is missing, or inapplicable

```sql
SELECT PName, Price, Manufacturer
FROM Product
WHERE Price <= 150 OR PRICE >= 150;
```

# SQL: 3-Valued Logic

For boolean expressions, the logic of conditions are either
- `TRUE`
- `FALSE`
- `UNKNOWN`

Comparing with NULL
- When any value is compared with `NULL`, the truth value is `UNKNOWN`

SQL Rules
- A query only produces a typle in the answer if its truth value for the `WHERE` clause is `TRUE` (not `FALSE` or `UNKNOWN`)

# `ORDER BY`: Sorting Results

```sql
SELECT PName, Price, Manufacturer
FROM Product
WHERE Category = 'Gadgets' AND Price < 50
ORDER BY Price, PName;
```

- Ordering is ascending unless you specify `DESC` keyword
    - `ORDER BY Price, PName DESC`
- Ties are broken by the second attribute on the `ORDER BY` list, etc.

## `NULL`s in `ORDER BY`

- `NULL` is normally treated as less than all non-null values

# Multi-Relation Queries

Sailors

| sid | sname | rating | age |
| --- | ----- | ------ | --- |
| 1   | Fred  | 7      | 22  |
| 2   | Jim   | 2      | 39  |
| 3   | Nancy | 8      | 27  |

Reserves

| sid | bid | bady |
| --- | --- | ---- |
| 1   | 102 | 9/12 |
| 2   | 102 | 9/13 |

```sql
SELECT S.sname
FROM Sailors S, Reserves R
WHERE S.sid = R.sid AND R.bid = 102;
```

# Subqueries

- Also called nested queries
- We can do nested queries because SQL is compositional
    - Everything (inputs/outputs) is represented as multisets - the output of one query can thus be used as the input to another (nesting)

## Types of Subqueries

- Scalar Subquery
    - Returns a single value which is then used in a comparison
    - If query expects a single value from a subquery and it returns multiple values or no values, a run-time error occurs
- Row Subquery
    - Returns a single row which may have multiple columns
- Table Subquery
    - Returns one or more columns and multiple rows 

### Scalar Subquery

E.g.: From `Sells(bar, beer, price)`, find the bars that serve Heineken for the same price `WOOBAR` charges for `Bud`

1. First, we find the price `WOOBAR` charges for `Bud`

```sql
SELECT price 
FROM Sells 
WHERE bar = 'WOOBAR' AND beer = 'Bud';
```

2. Find bars that serve Heineken for the same price

```sql
SELECT bar
FROM Sells
WHERE Sells.beer = 'Heineken' AND 
    Sells.price = (SELECT price 
                    FROM Sells 
                    WHERE bar = 'WOOBAR' AND beer = 'Bud');
```

### Row Subquery

Returns a single row which may have multiple columns
- Note that a single column with multiple rows is valid, as well as a single row with multiple columns

```sql
SELECT agent_name, agent_code, phone_no
FROM agents
WHERE agent_code = (
    SELECT agent_code 
    FROM agents
    WHERE agent_name = 'Alex'
);
```

#### Operators in Row Subquery

- `IN`
    - `<tuple> IN <relation>` is true if and only if the typle is a member of the relation

For example, if we had `Beers(name, manf)` and `Likes(drinker, beer)`, find the name and manufacturer of each beer that fred likes

```sql
SELECT name, manf
FROM beers
WHERE name IN(
    SELECT beer
    FROM Likes
    WHERE drinker = 'Fred'
)
```

- `ALL`
    - `x <> ALL(<relation>)` is true if and only if for every tuple `t` in the relation, `x` is not equal to `t`

From `Sells(bar, beer, price)`, find the beer(s) that sold for the highest price

```sql
SELECT beer
FROM Sells
WHERE price >= ALL (
    SELECT price
    FROM sells
)
```

- `ANY/SOME`
    - `x = SOME(<relation>)` is a boolean condition. Meaning that `x` **equals at least 1** tuple in the relation
    - Early version of SQL allowed `ANY`

From `Agents(agent_code, agent_name)`, `Customer(agent_code, cust_country)`, report all agents who belong to the country 'UK'

```sql
SELECT *
FROM Agents
WHERE agent_code = SOME(
    SELECT agent_code
    FROM Customer
    WHERE cust_country = 'UK'
)
```

### More Operators for Subquery

- Any of the comparison operators `<, <=, =`, etc.
- The keyword `NOT` can proceed any of the operators (`s NOT IN R`)

### Table Subquery

- Returns one or more columns and multiple rows

```sql
SELECT p1.name
FROM Product p1
WHERE p1.maker = 'Gizmo-Works'
AND EXISTS(
    SELECT *
    FROM Product p2
    WHERE p2.maker <> 'Gizmo-Works'
    AND p1.name = p2.name
);
```

This query select all products made by "Gizmo-Works" having the same names as products made by other companies

### `EXISTS`

The `EXISTS` operator is used to test for the existence of any record in a subquery. The `EXISTS` operator returns `TRUE` if the subquery returns one or more records.

```sql
SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);
```

### Uncorrelated Subqueries

- A subquery is uncorrelated if the subquery is not related to the outer query

### Correlated Subqueries

- A subquery is correlated with the outer query if it contains a reference to an attribute in the outer query
- A subquery is correlated with the outside query if it must be re-computed for every typle produced by the outside query

```sql
SELECT p1.name
FROM Product p1
WHERE p1.maker = 'Gizmo-Works'
AND EXISTS(
    SELECT *
    FROM Product p2
    WHERE p2.maker <> 'Gizmo-Works'
    AND p1.name = p2.name
);
```

## Subquery: Rules to Remember

- The `ORDER BY` clause may not be used in a subquery
- The number of attributes in the `SELECT` clause in the subquery must match the number of attributes wiht the comparison operator
- Column names in a subquery refer to the table name in the `FROM` clause of the subquery by default
- When the result of a subquery is used as an opearnd, it must be the right operand

# Set Operations in SQL: `UNION`, `INTERSECT`, `EXCEPT`

These set operations are used to combine the results of 2 separate SQL queries

- Every subquery must have the same number of columns
- Columns must also have similar data types
- Columns in every subquery must be in the same order

## `UNION`

The `UNION` operator is used to combine the result-set of 2 or more `SELECT` statements. Similar to the $\cup$ operator.


```sql
SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
```

For example, consider the following relations:

- Likes(**drinker**, **beer**)
- Sells(**bar**, **beer**, price)
- Frequents(**drinker**, bar)

Find the drinkers and beers such that
1. The drinker likes the beer
2. The drinker frequents at least one bar that sells the beer

```sql
SELECT *
FROM Likes

UNION

SELECT drinker, beer
FROM Frequents, Sells
WHERE Frequents.bar = Sells.bar;
```

## `EXCEPT`

Similar to the $-$ operator. Returns records returned by `query1` that are not in `query2`

```sql
SELECT query1
EXCEPT
SELECT query2
```

## `INTERSECTS`

The SQL `INTERSECT` operator is used to return the results of 2 or more `SELECT` statements. It only returns the **rows selected by all queries** or data sets. If a record exists in one query and not in the other, it will be omitted from the `INTERSECT` results. Similar to the $\cap$ operator

```sql
SELECT column_name(s) FROM table1
INTERSECT
SELECT column_name(s) FROM table2;
```

For example, consider 2 tables

- Company(**name**, hq_city)
- Product(**pname**, maker, factory_loc)

If we want to find the headquarters of companies which make products in both US and China, we can use the following query

```sql
SELECT name, hq_city
INTO HQ_Name
FROM Company, Product
WHERE maker = name AND factory_loc = 'US'

INTERSECT

SELECT name, hq_city
FROM Company, Product
WHERE maker = name AND factory_loc = 'China';

SELECT DISTINCT hq_city
FROM HQ_Name;
``` 

Let us break down this query. First, we select all companies who have factory locations in US

```sql
SELECT name, hq_city
FROM Company, Product
WHERE maker = name AND factory_loc = 'US';
```

Then we select all companies who have factory locations in China

```sql
SELECT name, hq_city
FROM Company, Product
WHERE maker = name AND factory_loc = 'China';
```

We intersect both of them to find companies who have factories both in US and China. We place this into a new table called `HQ_Name` using `SELECT INTO`

```sql
SELECT name, hq_city
INTO HQ_Name
FROM Company, Product
WHERE maker = name AND factory_loc = 'US'

INTERSECT

SELECT name, hq_city
FROM Company, Product
WHERE maker = name AND factory_loc = 'China';
```

Note how we did the intersection on BOTH `name` and `hq_city`. If we only did an intersect on `hq_city`, it may be wrong. For example, company X with `hq_city` in Seattle has a `factory_loc` only in China, while company Y also with `hq_city` in Seattle has `factory_loc` only in US


Finally, we want only the `hq_city`s of the companies who have factories in both US and China, hence

```sql
SELECT DISTINCT hq_city
FROM HQ_Name;
```

However, if we are only allowed to use a single SQL query, we can make use of subqueries

```sql
SELECT DISTINCT hq_city
FROM (
    SELECT name, hq_city
    FROM Company, Product
    WHERE maker = name AND factory_loc = 'US'
    INTERSECT
    SELECT name, hq_city
    FROM Company, Product
    WHERE maker = name AND factory_loc = 'China'
);
```

## Bag Semantics vs. Set Semantics

- Set semantics: No duplicates, each item appears only once
- Bag semantics: Duplicates allowed, i.e. a multiset
- Default for `SELECT-FROM-WHERE` is bag
- Default for `UNION`, `INTERSECT`, and `EXCEPT` is set

To change the default semantics,
- We can force set semantics with `DISTINCT` after `SELECT`
- We can force bag semantics with `ALL` after `UNION`

For example

### `SELECT` vs `SELECT DISTINCT` (Bag vs Set semantics)

```sql
SELECT DISTINCT category FROM Product
```

| Category    |
| ----------- |
| Gadgets     |
| Household   |
| Photography |

```sql
SELECT category FROM Product
```

| Category    |
| ----------- |
| Gadgets     |
| Photography |
| Household   |
| Household   |
| Photography |

### `UNION` vs. `UNION ALL`

Consider the following table

Likes

| Drinker | Beer     |
| ------- | -------- |
| Sally   | Heineken |
| Sean    | Bud      |
| Melissa | Tiger    |

Buys

| Drinker | Beer     |
| ------- | -------- |
| Sally   | Heineken |
| Sally   | Bud      |
| Melissa | Heineken |
| Melissa | Tiger    |

If we did the following sql query:

```sql
SELECT * FROM Likes
UNION ALL
SELECT * FROM Buys;
```

We will get the following table:

| Drinker | Beer     |
| ------- | -------- |
| Sally   | Heineken |
| Sean    | Bud      |
| Melissa | Tiger    |
| Sally   | Heineken |
| Sally   | Bud      |
| Melissa | Heineken |
| Melissa | Tiger    |

Note how `(Sally, Heineken)` and `(Melissa, Tiger)` is repeated twice. However, if we were to use

```sql
SELECT * FROM Likes
UNION
SELECT * FROM Buys;
```

We would get

| Drinker | Beer     |
| ------- | -------- |
| Sally   | Heineken |
| Sean    | Bud      |
| Sally   | Bud      |
| Melissa | Heineken |
| Melissa | Tiger    |


# Joins

A `JOIN` is used to combine rows from 2 tables or more, based on a related column between them. These are the joins we will be looking at

- `INNER JOIN`
- `NATURAL JOIN`
- `LEFT [OUTER] JOIN`
- `RIGHT [OUTER] JOIN`
- `FULL [OUTER] JOIN`

Consider the following table

Orders

| OrderID | CustomerID | OrderDate  |
| ------- | ---------- | ---------- |
| 10308   | 2          | 1996-09-18 |
| 10309   | 1          | 1996-09-19 |

Customers

| CustomerID | CustomerName                       | ContactName    | Country |
| ---------- | ---------------------------------- | -------------- | ------- |
| 1          | Alfreds Futterkiste                | Maria Anders   | Germany |
| 2          | Ana Trujillo Emparedados y helados | Ana Trujillo   | Mexico  |
| 3          | Antonio Moreno Taquería            | Antonio Moreno | Mexico  |

## Inner Join

![](https://www.w3schools.com/sql/img_innerjoin.gif)

The $\bowtie$ operator. Returns records that have matching values in both tables. If the condition is not an equality, but an inequality, it is the $\bowtie_{\theta}$ (theta join) operator. The syntax is as follows

```sql
SELECT column_name(s)
FROM table1
INNER JOIN table2
ON table1.column_name = table2.column_name;
```

For example: Return the orderID, customer name and order date of all the orders

```sql
SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
```

| OrderID | CustomerName                       | OrderDate  |
| ------- | ---------------------------------- | ---------- |
| 10308   | Ana Trujillo Emparedados y helados | 1996-09-18 |
| 10309   | Alfreds Futterkiste                | 1996-09-19 |

## Natural Join

`NATURAL JOIN` joins 2 tables together on all column that has the same name between both tables. The syntax for a natural join is as follows:

```sql
SELECT ...
FROM Table1
NATURAL JOIN Table2;
```

The `INNER JOIN` equivalent for the query above is

```sql
SELECT ...
FROM Table1
INNER JOIN Table2
ON Table1.Column1 = Table2.Column2;
```

Unlike `INNER JOIN`, `NATURAL JOIN` does not specify the columns. If `TableA` and `TableB` share multiple columns with the same name, all the column values must match

```sql
SELECT ...
FROM Table1
JOIN Table2
ON Table1.Column1 = Table2.Column1 AND Table1.Column2 = Table2.Column2;
```

Consider the following 2 tables

```
TableA                           TableB
+------------+----------+        +--------------------+    
|Column1     | Column2  |        |Column1  |  Column3 |
+-----------------------+        +--------------------+
| 1          |  2       |        | 1       |   3      |
+------------+----------+        +---------+----------+
```

The `INNER JOIN` of `TableA` and `TableB` on `Column1` will return

```sql
SELECT * FROM TableA AS a INNER JOIN TableB AS b ON TableA.Column1 = TableB.Column1; // Equivalently,
SELECT * FROM TableA AS a INNER JOIN TableB AS b USING Column1;
```

```
+------------+-----------+---------------------+    
| a.Column1  | a.Column2 | b.Column1| b.Column3|
+------------------------+---------------------+
| 1          |  2        | 1        |   3      |
+------------+-----------+----------+----------+
```

However, using `NATURAL JOIN` the query will return

```sql
SELECT * FROM TableA AS a NATURAL JOIN TableB AS b;
```

```
+------------+----------+----------+    
|Column1     | Column2  | Column3  |
+-----------------------+----------+
| 1          |  2       |   3      |
+------------+----------+----------+
```

The repeated column is avoided

## Left (Outer) Join

![](https://www.w3schools.com/sql/img_leftjoin.gif)

The $\mathring{\bowtie}_L$ operator. Returns all records on the left table, and matched records from the right table. Unmatched records on the right table will be `NULL`. The syntax is as follows

```sql
SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name = table2.column_name;
```

You can also optionally include the keyword `OUTER` in it, as it is optional. It is the same thing

```sql
SELECT ...
FROM table
LEFT OUTER JOIN table2
ON ...;
```

```sql
SELECT Customers.CustomerName, Orders.OrderID, Orders.OrderDate
FROM Customers
LEFT JOIN Orders
ON Customers.CustomerID=Orders.CustomerID
ORDER BY Customers.CustomerName;
```

| CustomerName                       | OrderID | OrderDate  |
| ---------------------------------- | ------- | ---------- |
| Alfreds Futterkiste                | 10309   | 1996-09-18 |
| Ana Trujillo Emparedados y helados | 10308   | 1996-09-18 |
| Antonio Moreno Taquería            | null    | null       |

## Right (Outer) Join

![](https://www.w3schools.com/sql/img_rightjoin.gif)

`RIGHT JOIN` returns all records from the right table (table2), and the matching records from the left table (table1). Similar to the $\mathring{\bowtie}_R$ operator.

```sql
SELECT column_name(s)
FROM table1
RIGHT JOIN table2
ON table1.column_name = table2.column_name;
```

You can also optionally include the keyword `OUTER` in it, as it is optional. It is the same thing

```sql
SELECT ...
FROM table
RIGHT OUTER JOIN table2
ON ...;
```

## Full Outer Join

![](https://www.w3schools.com/sql/img_fulljoin.gif)

Similar to the $\mathring{\bowtie}$ operator. The `FULL OUTER JOIN` or `FULL JOIN` keyword returns all matching records from both tables whether the other table matches or not. So, if there are rows in `table1` that do not have matches in `table2`, or if there are rows in `table2` that do not have matches in `table1`, those rows will be listed as well.

```sql
SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2
ON table1.column_name = table2.column_name
WHERE condition;
```

## Join Semantics

```sql
SELECT R.A
FROM R, S
WHERE R.A = S.B;
```

The above is equivalent to 

```sql
SELECT R.A
FROM R
INNER JOIN S
ON R.A = S.B;
```

A join is simply a 
1. Cross product of the 2 tables, then a 
2. Filter on the condition (the `ON` condition)
3. Project on the columns

(This is not exactly how a DBMS executes a join under the hood)

## `INNER JOIN USING` vs `INNER JOIN ON`

```sql
SELECT * FROM R
INNER JOIN S
USING <attribute-list>;

SELECT * FROM R
INNER JOIN S
ON R.column_name = S.column_name;
```

- `USING` is useful when both tables share a column of the exact same name on which they join. For example

    ```sql
    SELECT ... FROM film JOIN film_actor USING (film_id) WHERE ...;
    ```

- `ON` is more flexible than `USING` because it allows any valid boolean expression. To get the same query as above using `ON`:

    ```sql
    SELECT ... FROM film JOIN film_actor ON (film.film_id = film_actor.film_id) WHERE ...;
    ```

    We can also use any other boolean expression

    ```sql
    SELECT ... FROM Managers JOIN Employees ON (Mangers.ID = Employees.ManagerID AND Employees.salary > Mangers.salary);
    ```

## More Examples for Joins

1. Consider the following tables

    - Product(**PName**, Price, Category, Manufacturer)
    - Company(**CName**, StockPrice, Country)

    Find all countries that manufacture some products in the "Gadgets" category

    ```sql
    SELECT DISTINCT Country
    FROM Product
    INNER JOIN Company
    WHERE Product.Manufacturer = Company.CName; AND Product.Category = 'Gadgets';
    ```

    Note the use of `DISTINCT`, because the inner join has bag semantics, hence duplicates will not be removed. Since we only want the countries that manufacture some products in the "Gadgets" category, we should use `DISTINCT` to remove the duplicates

2. Consider the following SQL statement

    ```sql
    SELECT R.A
    FROM R, S, T
    WHERE R.A = S.A OR R.A = T.A;
    ```

    If `S` is an empty table, what is the output of the query above?

    Recall the semantics of the join
    1. Take cross product of `R`, `S`, `T`
    2. Apply selections/conditions
    3. Apply projection

    If `S` is empty, then the cross product of `R`, `S`, `T` is empty, and hence the query result is also empty

# Aggregation

Aggregate functions perform a calculation over a set of values. Examples of aggregate functions in SQL include:

- `COUNT` counts how many rows are in a particular column
- `SUM` adds together all the values in a particular column
- `MIN` and `MAX` return the lowest and highest values in a particular column respectivelyl
- `AVG` calculates the average of a group of selected values

Note: Except `COUNT`, all aggregations apply only to a single attribute (column)

For example,

```sql
SELECT AVG(Price)
FROM Product
WHERE maker = 'Toyota';
```

This returns the average price of all products made by Toyota

```sql
SELECT COUNT(*)
FROM Product
WHERE year > 1997;
```

This returns the number of products which were created after 1997

## Some rules regarding aggregate functions

- Counts the number of rows for a particular column. Note that `COUNT` **applies to duplicates** unless otherwise stated

    ```sql
    SELECT COUNT(category)
    FROM Product
    WHERE year > 1996;
    ```

    vs

    ```sql
    SELECT COUNT(DISTINCT category)
    FROM Product
    WHERE year > 1996;
    ```

- `COUNT`, `MAX`, `MIN` can apply to all types of fields (string, boolean, numeric etc.)
- `SUM` and `AVG` only apply to numeric fields
- Other than `COUNT(*)`, all functions ignore nulls
    - Consider the table Beer(beer, manufacturer)
    - `SELECT COUNT(manufacturer) FROM Beer` will
        - Ignore `NULL` manufacturers
        - Duplicate manufacturers will be counted

    - `SELECT COUNT(*) FROM Beer` will
        - Count `NULL` manufacturers
        - Count duplicate manufacturers

    - `SELECT COUNT(DISTINCT manufacturer) FROM Beer`
        - Counts the number of distinct manufacturers
        - Nulls are ignored
        - This is the same as 

        ```sql
        SELECT INTO Beer_Manufacturers DISTINCT manufacturer FROM Beer; // gets distinct, not-null manufacturers
        SELECT COUNT(manufacturer) FROM Beer_Manufacturers; // counts the number of rows returned by previous query
        ```

    - `SELECT DISTINCT COUNT(manufacturer) FROM Beer`
        - Counts the number of not-null manufacturers (including duplicates)
        - Nulls are ignored
        - This is the same as

        ```sql
        SELECT INTO Beer_Manufacturers COUNT(manufacturer) FROM Beer; // ignores null, counts duplicates
        SELECT DISTINCT Beer_Manufacturers; // since previous query returns only 1 row, DISTINCT does nothing
        ```
- `COUNT(*)` returns the number of rows in the table
- Use `DISTINCT` to eliminate duplicates

# `GROUP BY`

Consider the following relation: Purchase(**product**, **date**, price, quantity)

We want to find the total sales after 10/1/2005 per product. Total sale is defined as price * quantity, aggregated over all dates

```sql
SELECT product, SUM(quantity * price) AS TotalSales
FROM Purchase
WHERE date > '10/1/2005'
GROUP BY product;
```

## `GROUP BY` Semantics

1. Compute the `FROM` and `WHERE` clauses
2. Group by the attributes in `GROUP BY`
3. Compute the `SELECT` clause: Grouped attributes and aggregates

## `GROUP BY` Rules

All columns in the `SELECT` clause that do not have an aggregate need to be in the `GROUP BY`.

If there are no other columns, then no `GROUP BY` is needed

The following query is invalid because an aggregate function appears without a `GROUP BY`

```sql
SELECT bar, MIN(price)
FROM Sells
WHERE beer = 'bud';
```

While the following query is valid because we group by `beer` and aggregate on `price`

```sql
SELECT beer, AVG(price)
FROM Sells
GROUP BY beer;
```

While the following query is also valid because we only have 1 column we are aggregating on

```sql
SELECT AVG(price)
FROM Sells;
```

The following query is invalid because we are not grouping by `bar`, and `bar` appears without an aggregate function

```sql
SELECT bar, beer
FROM Sells
GROUP BY beer;
```

The following query is valid because the `beer` column in the `SELECT` clause is a column we are grouping by

```sql
SELECT beer
FROM Sells
GROUP BY beer;
```

The following query is valid because the `price` column in the `SELECT` clause is within an aggregate function, and we are not grouping by `price`

```sql
SELECT AVG(price)
FROM Sells
GROUP BY beer;
```

We can also `GROUP BY` multiple attributes. We will execute the `GROUP BY` on the first attribute. Then for every group of the first attribute, we `GROUP BY` the second attribute

```sql
SELECT beer
FROM Sells
GROUP BY bar, beer;
```

# `HAVING`

Consider the following relation: Purchase(**product**, **date**, price, quantity)

Find the total sales after 10/1/2005 per product, for those products that have more than 100 buyers

```sql
SELECT product, SUM(price * quantity)
FROM Purchase
WHERE date > '10/1/2005'
GROUP BY product
HAVING SUM(quantity) > 100;
```

`HAVING` clauses contains conditions on **aggregates** (i.e. groups), while `WHERE` clauses condition on **individual tuples**. A simple rule of thumb is to use `WHERE` before `GROUP BY`s and `HAVING` after `GROUP BY`s (applies to 90% of the time). 

## More Examples with `HAVING`

From Sells(**bar**, **beer**, price), find the average price of those beers that are served in at least 2 bars

```sql
SELECT AVG(price)
FROM Sells
GROUP BY beer
HAVING COUNT(bar) >= 2;
```

From the same relation, find the average price of beers that are served in at least 2 bars, and price in each bar is less than 9 dollars

```sql
SELECT AVG(price)
FROM Sells
WHERE price < 9.00
GROUP BY beer
HAVING COUNT(bar) >= 2;
```

Similarly, we can also use an `EVERY` within the `HAVING` clause

```sql
SELECT AVG(price)
FROM Sells
GROUP BY beer
HAVING COUNT(bar) >= 2 AND EVERY(price < 9.00);
```

Consider the following relations

- Author(login, name)
- Wrote(login, url)

An author can have many logins. In every login, she writes many urls (blogs)

Find authors who wrote at least 10 documents

```sql
SELECT Author.name
FROM Author
INNER JOIN Wrote
ON Author.login = Wrote.login
GROUP BY Author.name
HAVING COUNT(url) >= 10;
```

Note: No need for `DISTINCT` because duplicates are automatically removed thanks to `GROUP BY` (set semantics)

# General Form for Grouping and Aggregation

```sql
SELECT expression1, expression2, ...
FROM table1, table2, ..., tableR
WHERE condition
GROUP BY attribute1, attribute2, ... attributeK
HAVING condition2
```

1. Evaluate the `FROM-WHERE` clause: Apply `condition` on the attributes in table1, table2, ...
2. `GROUP BY` the attributes
3. Apply `condition2` to each group (may have aggregates)
4. Compute aggregates in `expression`s and return the result

Note that 
- `expression`s must only contain attributes `atttribute1`, ..., `attributeK`, and/or aggregates over other attributes
- `condition1` is any condition over the attributes in `table1, table2, ... tableR`
- `condition2` is any condition on the aggregate expressions (i.e. groups)

# SQL Data Definition Language (DDL) Overview

Data Definition Language
- Add, modify and drop tables
- Create views
- Define and enforce integrity constraints
- Enforce security restrictions

For example, 

```sql
CREATE TABLE <name> (
    <list of elements>
);

DROP TABLE <name>;
```

## `CREATE TABLE`

Creates a table with a list of attributes

```sql
CREATE TABLE Sells (
    bar CHAR(20),
    beer VARCHAR(20),
    price REAL
)
```

Each element is a pair consisting of an **attribute** and a **type**. Data types in SQL include

- `INT` or `INTEGER`
- `REAL` or `FLOAT`
- `CHAR(n)`, a fixed-length character string of `n` characters
- `VARCHAR(n)`, a variable-length string of up to `n` characters
- `DATE` in `yyyy-mm-dd` format
- `TIME` in `hh:mm:ss` format

## `ALTER TABLE`

Updates a relation schema, either adding or deleting attributes from the schema. 

We can add attributes to a relation by

```sql
ALTER TABLE <name>
ADD <attribute-declaration>
```

We can remove attributes from a relation by

```sql
ALTER TABLE <name>
DROP <attribute-name>
```

```sql
ALTER TABLE Bars
ADD phone CHAR(10)
DEFAULT 'unlisted';

ALTER TABLE Bars
DROP license;
```

# Database Modification

A modification command does not return a result as a query does, however it changes the database in some way. Types of modifications include

- Inserting tuple(s)
- Deleting tuple(s)
- Update the value(s) of existing tuple(s)

## `INSERT INTO`

Inserts tuple(s) into a relation

```sql
INSERT INTO <relation>
VALUES (
    <list of values>
);
```

For example, if we wanted to add to Likes(**drinker**, **beer**) the fact that Sally likes Bud,

```sql
INSERT INTO Likes
VALUES (
    'Sally', 'Bud'
);
```

We can also specify the order of columnsL

```sql
INSERT INTO Likes(beer, drinker)
VALUES (
    'Bud', 'Sally'
);
```

The columns don't have to be the same order as in the table

For inserting multiple tuples, we can insert the entire result of a query into a relation, using the form `INSERT INTO <relation> (<subquery>)`

For example,

Using Frequents(**drinker**, **bar**), enter in the new relation PotBuddies(**name**), all of Sally's potential buddies, i.e., those drinkers who frequent at least one bar that Sally also frequents

To get drinkers who frequent at least one bar that Sally also frequents,

```sql
SELECT DISTINCT drinker
FROM Frequents
WHERE bar IN (
    SELECT bar
    FROM Frequents
    WHERE drinker = 'Sally'
)
```

Then we can insert this entire subquery into a new relation

```sql
CREATE TABLE Potbuddies (
    name VARCHAR(30)
);

INSERT INTO Potbuddies (
    SELECT DISTINCT drinker
    FROM Frequents
    WHERE bar IN (
        SELECT bar
        FROM Frequents
        WHERE drinker = 'Sally'
    )
);
```

## `DELETE FROM`

Deletes tuples from a relation that satisfy a condition

```sql
DELETE FROM <relation>
WHERE <condition>;
```

For example, 

```sql
DELETE FROM Likes
WHERE drinker = 'Sally' AND beer = 'bud';
```

### More Examples for `DELETE FROM`

Delete from Beers(name, manf) all beers for which there is another beer by the same manufacturer

```sql
DELETE FROM Beers AS b
WHERE EXISTS (
    SELECT name
    FROM Beers
    WHERE manf = b.manf AND name <> b.name
);
```

## `UPDATE`

Update attribute values in a relation

```sql
UPDATE <relation>
SET <list of attribute assignments>
WHERE <condition on tuples>
```

For example, if we want to change drinker Fred's phone number to 6555-1212,

```sql
UPDATE Drinkers
SET phone = '6555-1212'
WHERE name = 'Fred';
```

# Constraints

A constraint is a particular relationship among data elements that a DBMS is required to enforce

Types of constraints include:
- Keys
- Foreign keys or referential integrity
- Value-based constraints
    - Constrain values of a specific attribute
- Tuple-based constraints
    - Relationshiop among components
- Assertions: Any SQL boolean expression

## Attribute-based Checks

```sql
CREATE TABLE Sells (
    bar CHAR(20),
    beer CHAR(30) CHECK (beer IN (SELECT name FROM Beers)),
    price REAL CHECK (price <= 18)
);
```

An attribute-based check is checked only when a value for that attribute is inserted or updated. Attribute is not checked at time of deletion.
- In the table creation, follow the attribute bya condition that must hold for that attribute in each tuple of its relation
- `CHECK(condition)`
    - Condition may involve the checked attribute
    - Other attibutes and relations may be involved, but only in subqueries

## Tuple-based Checks

- Separate element of table declaration
- Like attribute-based check, however conditino can refer to any attribute of the relation
    - Or to other relations/attributes in subqueries
- Checked whenever a tuple is inserted/updated

```sql
CREATE TABLE Sells (
    bar CHAR(20),
    beer CHAR(30),
    price REAL,
    CHECK (bar = 'WOOBAR' OR price <= 10)
);
```

The query above implies that only `WOOBAR` can sell beers above $10.

## Assertions

- Database schema constraints, which are not available within many DBMS
- Conditions can refer to any relation or attribute in the database schema
- We must check every `ASSERTION` after every modification to any relation of the database

```sql
CREATE ASSERTION <name>
CHECK (condition);
```

For example, to create an assertion that check if Sells(**Bar**, **Beer**, Price), no bar may charge an average of more than $10

```sql
CREATE ASSERTION averagePriceBelow10
CHECK (
    NOT EXISTS (
        SELECT Bar
        FROM Sells
        GROUP BY Bar
        HAVING AVG(Price) > 10
    )
);
```

# Views

A view is the dynamic reuslt of a query over the base relations to produce another relation
- It is considered **virtual** because it does not usually exist inside the database, but rather calculated only when needed
- A view appears just like any other table and can be present in any SQL query where a table is present

```sql
CREATE VIEW <name> AS <query>;
```

E.g., CanDrink(drinker, beer) is a view containing the drinker-beer pairs such that the drinker frequents at leaste 1 bar that serves the beer

```sql
CREATE VIEW CanDrink AS
SELECT drinker, beer
FROM Frequents, Sells
WHERE Frequents.bar = Sells.bar;
```

Using this view, we can query the view as if it were a base table

```sql
SELECT *
FROM CanDrink
WHERE drinker = 'Sally';
```

The DBMS maps a query expressed on views into a query expressed on base relations at compile time.

## Update with Views

- All views can be queried as base relations, but not all views can be manipulated
- A view is updateable only if the updates to the view can be propagated to the base relations **without ambiguity**

For example,

Consider the relation Drinkers(**name**, addr, phone), and the view `UnivDrinker`, which contains all the drinkers from either NTU or NUS

```sql
CREATE VIEW UnivDrinker AS
SELECT name, addr
FROM Drinkers
WHERE addr = 'NTU' OR addr = 'NUS';
```

If we wanted to update the view

```sql
INSERT INTO UnivDrinker
VALUES ('Sally', 'NUS');
```

This will work because the insertion is unambiguous. It will be compiled into the following equivalent insert statment

```sql
INSERT INTO Drinkers VALUES
('Sally', 'NUS', NULL);
```

Similarly, let us consider the view `NTUDrinker`, of all the drinkers in NTU

```sql
CREATE VIEW NTUDrinker AS
SELECT name
FROM Drinkers
WHERE addr = 'NTU';
```

Now, if we wanted to do the following insert statement

```sql
INSERT INTO NTUDrinker
VALUES ('Sally');
```

This is valid, and inserts the tuple `('Sally', 'NTU', NULL)` into the `Drinkers` table.

However, let us consider another relation. Consider Sells(**bar**, **beer**, price) and Frequents(**drinker**, **bar**), and the view

```sql
CREATE VIEW CanDrink AS
SELECT drinker, beer
FROM Frequents, Sells
WHERE Frequents.bar = Sells.bar;
```

If we wanted to perform the following insert statement

```sql
INSERT INTO CanDrink
VALUES ('Sally', 'Heineken');
```

This would not work, because `bar` is missing a value, and is required since it is part of the keys for `Sells` and `Frequents`

### Differences between Updatable and Unupdatable Views

Updatable view
- Only if they are derived from a **single relation** by **selection** and **projection**

Unupdatable view
- Views defined using **groups** and **aggregate** functions are not updatable
- Views defined on **multiple tables** using joins are generally not updatable, unless they include the **keys of the base relations**

## Temporary Views

`WITH` clause
- Allows to define a temporary view whose definition is only available to the query in which the `WITH` clause occurs
- Introduced in SQL99, and only supported by some DBMS vendors

```sql
WITH CanDrink(drinker, beer) AS
    SELECT drinker, beer
    FROM Frequents, Sells
    WHERE Frequents.bar = Sells.bar
SELECT drinker
FROM CanDrink
WHERE beer = 'Tiger`;
```

Similar to the `with` keyword in python

```python
with open('filename.txt', 'r') as f:
    f.read()
```

`WITH` makes the logic simpler to follow, and permits a view definition to be used multiple times in a query

### Views vs Temporal Views

- Views can be used in many queries in the future
- Temporal views can only be used in the current query

# Declaring Keys

## Primary Key

- An attribute or list of attributes may be declared `PRIMARY KEY` or `UNIQUE`
- They functionally determine all the attributes of the relation schema

To define a `PRIMARY KEY`, we either add `PRIMARY KEY` or `UNIQUE` after declaring the attribute


```sql
CREATE TABLE documents (
    documentId INT PRIMARY KEY
    ...
)
```

```sql
CREATE TABLE users (
    name VARCHAR(255) UNIQUE
    ...
)
```

Note that 
- Any table can only have 1 primary key, but can have multiple unique keys. 
- No attribute of a `PRIMARY KEY` can ever be `NULL`, however attributes declared `UNIQUE` may have `NULL`s
- Primary keys are used to uniquely identify a row, but a unique key is used to prevent duplicate values in a column.

If multiple attributes make up the key (composite key), then we separately declare it

```sql
CREATE TABLE voting (
    QuestionID NUMERIC,
    MemberID NUMERIC,
    PRIMARY KEY (QuestionID, MemberID)
);
```

## Foreign Keys

Consider the relation Sells(**Bar**, **Beer**, Price). The `Beer` entry in `Sells` must be a "real" beer (i.e. coms from the `Beers` table). A constraint which requires that a beer in `Sells` must also be a `name` in `Beers` is called a **foreign key constraint**

```sql
CREATE TABLE Beers (
    name CHAR(30) PRIMARY KEY,
    manf VARCHAR(50)
);

CREATE TABLE Sells (
    bar CHAR(20),
    beer VARCHAR(20),
    price REAL,
    PRIMARY KEY (bar, beer),
    FOREIGN KEY beer REFERENCES Beers(name)
);
```

- Use the `REFERENCES` keyword
- `FOREIGN KEY (<attribute list>) REFERENCES <relation>(<attributes>)`
- Referenced attributes must be declared as the `PRIMARY KEY` in the other table

### Foreign Key Violations

- `INSERT` or `UPDATE` a `Sells` tuple so it refers to a non-existent beer is **always rejected**
- `DELETE` or `UPDATE` a `Beers` tuple that has a beer some `Sells` tuples refer to
    - By default reject
    - `CASCADE`: ripple changes to referring `Sells` tuple
    - `SET NULL` change referring tuples to have `NULL` in referring components

- When we declare a foreign key, we may choose policies `SET NULL` or `CASCADE` independently for deletions and updates
- `ON [UPDATE, DELETE] [SET NULL, CASCADE]`

```sql
CREATE TABLE Sells (
    bar CHAR(20),
    beer CHAR(30),
    price REAL,
    FOREIGN KEY beer REFERENCES Beers(name)
    ON DELETE SET NULL
    ON UPDATE CASCADE
)
```

# `NOT NULL` and `DEFAULT`

- `NOT NULL` prevents `NULL` values from being inserted/updated in a tuple
- When inserting a row/tuple, `DEFAULT` inserts a default value for the tuple if no value is provided to it

```sql
CREATE TABLE Drinkers (
    name CHAR(30) PRIMARY KEY,
    address VARCHAR(255) DEFAULT '123 Sesame Street',
    phone CHAR(10) NOT NULL
);
```

```sql
INSERT INTO Drinkers(name, phone)
VALUES ('Sally', '12345667');
```

This would insert the tuple `('Sally', '123 Sesame Street', '12345667')`. However, if we were to do:

```sql
INSERT INTO Drinkers(name, phone)
VALUES ('Sally');
```

It would cause an error because `phone` cannot be null

# Quantifiers

There are multiple quantifiers available in SQL
- `ALL`: Universal quantifier
- `SOME` or `ANY`: Existential quantifier

## Existential Quantifier

An existential quantifier is a logical quantifier (roughly) of the form "there exists".

For example, from the relations Product(name, price, company) and Company(name, city), find all companies that make **some** products with price < 100

```sql
SELECT DISTINCT Company.name
FROM Company, Product
WHERE Company.name = Product.name AND price < 100;
```

## Universal Quantifier

A universal quantifier is a logical quantifier of the form "for all"

For example, from the relations Product(name, price, company) and Company(name, city), find all companies that make products **all** having price < 100

```sql
SELECT DISTINCT Company.name
FROM Company
WHERE Company.name NOT IN (
    SELECT Product.company
    FROM Product.price >= 100
)
    ```

# Trigger

A trigger is a special type of stored procedure that automatically runs when an event occurs in the database server. For example, a trigger can occur when a row is deleted, inserted or updated.

Instead of using a foreign-key constraint to reject a insertion into Sells(bar, beer, price) with unknown beer, a trigger can add that beer to Beers(name, manufacturer) relation with a `NULL` manufacturer

```sql
CREATE TRIGGER BeerTrig
AFTER INSERT ON Sells
REFERENCING NEW ROW AS newTuple
FOR EACH ROW
WHEN newTuple.beer NOT IN ( SELECT name FROM Beers )
INSERT INTO Beers(name)
VALUES (newTuple.beer)
```

The general syntax for a trigger is

```sql
CREATE TRIGGER triggerName
{ BEFORE | AFTER | INSTEAD OF }
    { INSERT | DELETE | UPDATE [OF columnNameList] }
ON tableName
    [ REFERENCING 
        [OLD ROW AS varToReferToOldTuple]
        [NEW ROW AS varToReferToNewTuple]
        [OLD TABLE AS nameToReferToOldTable]
        [NEW TABLE AS nameToReferToNewTable]
    ]
FOR EACH { ROW | STATEMENT }
[WHEN (precondition)]
[BEGIN]
listOfActions;
[END];
```

Example: Assume a database has a relation `Employee` with an attribute `Salary`. Enforce a constraint that caps at 5% any salary raises acheived by a single transaction

```sql
CREATE TRIGGER capSalaryRaise
AFTER UPDATE OF Salary ON Employee
REFERENCING 
    OLD ROW AS beforeSalaryRaise
    NEW ROW AS afterSalaryRaise
FOR EACH ROW
WHEN beforeSalaryRaise.Salary * 1.05 < afterSalaryRaise.Salary
    UPDATE Employee
    SET Salary = beforeSalaryRaise * 1.05
    WHERE Employee.id = beforeSalaryRaise.id;
```

## Triggering Condition

- Instead of immediately preventing the event that awakened it, a trigger tests a condition
    - Any condition allowed in the `WHERE` clause
    - Any SQL boolean-valued expression
- Trigger consideration
    - When? After activation, the condition specified in the trigger is checked
    - Conditions of all triggers activated by an event are checked immediately when the event is requested
    - It is evaluated before or after the triggering event depending on whether `BEFORE` or `AFTER` is used in the event
- Optionality
    - `WHEN` is optional
    - If `WHEN` is missing, then the action is executed whenever the trigger is awakened

## Trigger Action

- If the condition of the trigger is satisfied, the action associated with the trigger is performed by the DBMS
- Types of actions include
    - A SQL query, a `DELETE`, `INSERT`, `UPDATE`, `ROLLBACK`, `SQL`/`PSM`
    - Queries make no sense in an action, hence actions are usually database modifications

## Trigger Execution

A trigger can be executed
- After the triggering event
- Before the triggering event
- Instead of the event (useful for view modification)

### `AFTER`
- Executes entirely after the triggering event has applied its changes to the database
- Allowed to make changes to the database
- Can activate other triggers

For example, keep track of all the bars that raise the prices of their beers by more than $1
```sql
CREATE TRIGGER PriceTrig
AFTER UPDATE OF Price ON Sells
REFERENCING NEW ROW AS N
            OLD ROW AS O
FOR EACH ROW
WHEN N.price > O.price + 1
INSERT INTO RipOffBars
VALUES (new.bar)
```

### `BEFORE`, `INSTEAD OF`

How can an action caused by a real life event execute before or instead of that event?
- The event is a request to the DBMS issued by a transaction
- Possible for the DBMS to ignore the request and execute the trigger instead
- System might execute the trigger first, and then allow the requested action to occur

For `BEFORE` statements, they execute entirely before the triggering events
- `WHEN` condition is tested before the triggering event
    - If the condition is true, then the action of the trigger is executed
    - Next, the event that awakened the trigger is executed, regardless of whether the condition is true
- Note: `BEFORE` triggers are **not allowed to modify the database**
    - Only test the precondition in the `WHEN` clause and either accept, abort, or update the triggering transaction
    - Does not activate other triggers

For example,

```sql
CREATE TRIGGER Last_Name_Upper
BEFORE INSERT ON Employee
REFERENCING NEW ROW AS N
FOR EACH ROW
N.Last_Name = Upper(N.Last_Name);
```

This trigger ensures the the last name is always capitalised. The trigger updates the `INSERT` query

#### Triggers on Views

- Generally it is impossible to modify views because it doesn't exist
- `INSTEAD OF` trigger lets us interpret view modification in a way that makes sense

For example, we will design a view `Synergy` that has (**drinker**, **beer**, **bar**) tuples, such that the bar serves the beer and the drinker frequents the bar and likes the beer

```sql
CREATE VIEW Synergy AS
SELECT Likes.drinker, Likes.Beer, Sells.bar
FROM Likes, Sells, Frequents
WHERE Likes.drinker = Frequents.drinker AND Likes.beer = Sells.beer AND Sells.bar = Frequents.bar
```

We want to use an `INSTEAD OF` trigger to turn a (drinker, beer, bar) tuple into 3 insertions of projected pairs

```sql
CREATE TRIGGER ViewTrig
INSTEAD OF INSERT ON Synergy
REFERENCING
    NEW ROW AS n
FOR EACH ROW
BEGIN
    INSERT INTO Likes VALUES (n.drinker, n.beer);
    INSERT INTO Sells(bar, beer) VALUES (n.bar, n.beer);
    INSERT INTO Frequents VALUES (n.drinker, n.bar);
END;
```

Now, if we run an `INSERT` query onto the `Synergy` view, instead of running the actual `INSERT`, it will run the 3 insertions of the projected pairs

### Trigger Execution Granularity

Row level
- `FOR EACH ROW` indicates row-level
- Row-level triggers are executed once for each modified (inserted, updated, or deleted) tuple/row

```sql
CREATE TRIGGER BeerTrig
AFTER INSERT ON Sells
REFERENCING NEW ROW AS newTuple
FOR EACH ROW
WHEN newTuple.beer NOT IN ( SELECT name FROM Beers )
INSERT INTO Beers(name)
VALUES (newTuple.beer);
```

Statement level
- Executed once for an SQL statement, regardless of the number of tuples modified
- An `UPDATE` statement that makes no changes (condition in the `WHERE` clause does not affect any tuples) is an event that can still cause a trigger to execute on a statement level

```sql
CREATE TRIGGER RecordNewAvg
AFTER UPDATE OF Salary ON Employee
FOR EACH STATEMENT
INSERT INTO Log
VALUES (Current_Date, SELECT AVG(Salary) FROM Employee);
```

### Trigger referencing

`INSERT` 
- New tuple for row-level
- A set of new tuples for statement-level

`DELETE`
- Old tuple or table

`UDPATE` statement
- Both old and new 

Syntax: `REFERENCING [OLD NEW] [TUPLE TABLE] AS <name>`

For example, how to loop over all rows in the modified table? Lets say we want to enforce AB -> C for every insertion into R(A, B, C, D, **E**)

```sql
CREATE TRIGGER fd_enforcer_insert
BEFORE INSERT ON R
FOR EACH ROW
DECLARE counter INT
BEGIN
    SELECT COUNT(*) INTO counter
    FROM R
    WHERE R.A = NEW.A AND R.B = NEW.B AND R.C <> NEW.C;
    IF (counter > 0)
        THEN raise_exception('AB->C on R was violated');
END;
```

Note that `NEW` refers to the new row. We can do the exact same thing with the following SQL statement as well
- By default `OLD` maps to a single deleted (or, updated) row
- `NEW` maps to a single inserted (or, updated) row

```sql
CREATE TRIGGER fd_enforcer_insert
BEFORE INSERT ON R
REFERENCING NEW ROW AS N
FOR EACH ROW
DECLARE counter INT
BEGIN
    SELECT COUNT(*) INTO counter
    FROM R
    WHERE R.A = N.A AND R.B = N.B AND R.C <> N.C;
    IF (counter > 0)
        THEN raise_exception('AB->C on R was violated');
END;
```

Consider the next example here: 

```sql
CREATE TRIGGER FLIGHTS_DELETE
AFTER DELETE ON FLIGHTS
REFERENCING OLD TABLE AS DELETED_FLIGHTS
FOR EACH STATEMENT
BEGIN
DELETE FROM FLIGHT_AVAILABILITY
WHERE FLIGHT_ID IN
    (SELECT FLIGHT_ID FROM DELETED_FLIGHTS);
END;
```

Over here, what does `OLD TABLE` refer to?
- `OLD TABLE` is not the old version of `FLIGHT` table before deletion
- `OLD TABLE` maps all rows affected by the triggering event (i.e. only deleted rows of FLIGHT due to the execution of the triggering SQL statement)
- Likewise `NEW TABLE` maps all rows affected by the triggering event

# Indexes

Consider the following query:

```sql
SELECT price
FROM Sells
WHERE supplName = 'Apple' AND prodName = 'iPhone';
```

When the relation is large, it is expensive to scan all tuples to find a few relevant one. 

# Summary

## Simple SQL Selection (`SELECT FROM WHERE`)

```sql
SELECT userId, name
FROM Users
WHERE age > 18;
```

## Eliminate Duplicates with `DISTINCT`

```sql
SELECT DISTINCT Category
FROM Products
WHERE manufacturer = 'Yamaha';
```

## Rename Attributes and Tables with `AS`

```sql
SELECT PName AS Product, Price AS Cost, Manufacturer
FROM Products AS P
WHERE Category = 'Gadgets';
```

## Include Expressions in `SELECT` Clause

```sql
SELECT PName, Price * 1.4 AS Cost_In_SGD
FROM Product
WHERE Category = 'Furniture';
```

## Compound Boolean Expressions in `WHERE` Clause with `AND`, `OR`, `BETWEEN`, `IN`

```sql
SELECT *
FROM User
WHERE ((age BETWEEN 18 AND 25) OR (domain = 'ADMIN')) AND balance > 4000;
```

```sql
SELECT name, price 
FROM Product
WHERE manufacturer IN ('Samsung', 'Hitachi');
```

## String Matching with `LIKE`

```sql
SELECT *
FROM Products
WHERE PName LIKE '%gizmo%'; // rows where products have the substring 'gizmo'
```

- `%` = any sequence of characters
- `_` = any single character

## `NULL`

- Represents values that are missing, or inapplicable

## Sort results with `ORDER BY`

```sql
SELECT PName, Price, Manufacturer
FROM Product
WHERE Category = 'Gadgets'
ORDER BY Price, PName; // increasing order

SELECT PName, Price, Manufacturer
FROM Product
WHERE Category = 'Gadgets'
ORDER BY Price, PName DESC; // decreasing order
```

## Multi-Relation Queries

Can have more than 1 relation in the query

```sql
SELECT S.sname
FROM Sailors AS S, Reserves AS R
WHERE S.sid = R.sid;
```

## Subqueries

```sql
SELECT bar
FROM Sells
WHERE beer = 'Heineken' AND 
price = (
    SELECT price
    FROM Sells
    WHERE bar = 'WOOBAR'
    AND beer = 'Bud'
);
```


# Resources

- https://www.w3resource.com/sql/subqueries/single-row-subqueries.php
- https://www.w3schools.com/sql/sql_join_left.asp
- https://www.w3schools.com/sql/sql_join_inner.asp
- https://www.w3schools.com/sql/sql_join_right.asp
- https://www.w3schools.com/sql/sql_union.asp
- https://mode.com/sql-tutorial/sql-aggregate-functions/
- https://stackoverflow.com/questions/33589606/select-distinct-countid-vs-select-countdistinct-id
- https://stackoverflow.com/questions/11366006/mysql-join-on-vs-using
- https://stackoverflow.com/questions/6467216/is-it-possible-to-use-aggregate-function-in-a-select-statment-without-using-grou




