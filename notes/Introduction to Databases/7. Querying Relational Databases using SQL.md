# Querying Relational Databases using SQL

# What is SQL

- Structured Query Language (SQL) is a standard query language for relational databases

# What can we do with SQL?

- Manage and query the database (a set of relations/tables)
- Retrieve
- Insert
- Delete
- Update

SQL is declarative
- A SQL query specifies what to retrieve, but not how to retrieve it (procedural)

# Functions Supported by SQL

Data Manipulation Language (DML)
- Perform queries
- Perform updates (add/delete/modify)

Data Definition Language (DDL)
- Creates databases, tables, indices
- Creates views
- Specify authorisation
- Specify integrity constraints

Embedded SQL
- Wrap a high-level programming language around DML to do more sophisticated queryies/updates

# Tables in SQL

A relation or table is a multiset of tuples having the attributes specified by the schema. 
- A multiset is an unordered list (or: a set with multiple duplicate instances allowed)

For example: 

| PName       | Price | Manufacturer |
| ----------- | ----- | ------------ |
| Gizmo       | 20    | GizmoWorks   |
| Powergizmo  | 30    | GizmoWorks   |
| SingleTouch | 150   | Canon        |
| MultiTouch  | 204   | Hitachi      |

## Attributes (Columns) in a Table

An attribute (or column) is a typed data entry present in each tuple in the relation
- Attributes must have an atomic type in sstandard SQL, i.e. not a list, set, etc.

## Tuples (Rows) in a Table

A tuple or row is a single entry in the table having the attributes specified by the schema
- Also referred to sometimes as a record

## More on Tables

- The number of tuples is the cardinality of the relation
- The number of attributes is the arity of the relation

# Data Types in SQL

Atomic types
- Characters: `CHAR(20)`, `VARCHAR(50)`
- Numbers: `INT`, `BIGINT`, `SMALLINT`, `FLOAT`
- Others: `MONEY`, `DATETIME`

Every attribute must have an atomic type
- Hence the tables are flat

# Schema of a Table

| PName       | Price | Manufacturer |
| ----------- | ----- | ------------ |
| Gizmo       | 20    | GizmoWorks   |
| Powergizmo  | 30    | GizmoWorks   |
| SingleTouch | 150   | Canon        |
| MultiTouch  | 204   | Hitachi      |

- The schema of table is the table name, its attributes, and their types:

```
Product(Pname: string, Price: float, Manufacturer: string)
```

- A key is an attribute whose values are unique; we underline a primary key

# Principle Form of SQL

Basic Structure of SQL

```
SELECT desired attributes (A1, A2, ..., An)
FROM one or more tables (R1, R2, ..., Rm)
WHERE condition about tuples of the tables (P)
```

Mapping to Relational Algebra

$$
\Pi_{A_1, A_2, ..., A_n} (\sigma_P (R_1 \times R_2 \times \cdot \times R_m))
$$

# SQL Syntax

## Reserved words/Keywords

- There is a set of reserved words that cannot be used as names for database objects
- `SELECT`, `FROM`, `WHERE`, etc.

## Case-insensitive

- SQL is generally case-insensitive
    - Exception: String constants are case sensitive ('FRED' vs 'fred')
- Use single quotes for constants
    - 'abc' is valid
    - "abc" is invalid
- White-space is ignored
- All statements end with a semicolon;

# Simple SQL Query: Selection

Selection is the operation of filtering a relation's tuples on some condition

```sql
SELECT *
FROM Product
WHERE Category = 'Gadgets';
```

This query selects all columns from the `Product` relation, where `Category = 'Gadgets'`

# Simple SQL Query: Projection

Projection is the operation of producing an output table with typles that have a subset of their prior attributes

```sql
SELECT PName, Price, Manufacturer
FROM Product
WHERE Category = 'Gadgets';
```

This query selects the specific columns: `PName`, `Price`, `Manufacturer` from the relation `Product`, where `Category = 'Gadgets'`

# `DISTINCT`: Eliminating Duplicates

```sql
SELECT DISTINCT Category 
FROM Product;
```

# `AS`: Renaming Attributes

```sql
SELECT PName AS Product, Price AS Cost, Manufacturer
FROM Product
WHERE Category = 'Gadgets'
```

# Expressions in `SELECT` Clause

```sql
SELECT PName, Price * 1.4 AS Cost_IN_SGD, Manufacturer
FROM Product
WHERE Category = 'Gadgets'
```

# Complex Conditions in `WHERE` Clause

## `AND`

Both sides of the `AND` condition must be true for the row to be selected

```sql
SELECT Pname, Price, Manufacturer
FROM Product
WHERE Category = 'Gadgets' AND Price < 20
```

## `BETWEEN`

Check if value of attribute must be between 2 values

```sql
SELECT PName, Price, Manufacturer
FROM Product
WHERE Price BETWEEN 10 AND 20
```

## `IN`

Check whether value is included in a collection

```sql
SELECT PName, Price, Manufacturer
FROM Product
WHERE Manufacturer IN ('GizmoWorks', 'Samsung', 'Hitachi')
```

## `LIKE` (String Pattern Matching)

`s LIKE p`: Pattern matching on strings. Patterns are case sensitive
- `p` may contain 2 special symbols
    - `%`: any sequence of characters
    - `_`: any single character

```sql
SELECT *
FROM Products
WHERE PName LIKE '%gizmo%';
```

This query selects all products where the `PName` contains the word `'gizmo'`

- `'John%'` - Matches any string beginning with "John"
- `'%ohn%' - Matches any string containing "ohn" as substring
- `'___'` - Matches any string with exactly 3 characters
- `'___%'` - Matches any string of at least 3 characters
- `'ab\%cd%'` - Matches all strings beginning with "ab%cd"

# `NULL` Values

Tuples in SQL relations can have `NULL` as value for one or more attributes. It means that a value is missing, or inapplicable

```sql
SELECT PName, Price, Manufacturer
FROM Product
WHERE Price <= 150 OR PRICE >= 150;
```

# SQL: 3-Valued Logic

For boolean expressions, the logic of conditions are either
- `TRUE`
- `FALSE`
- `UNKNOWN`

Comparing with NULL
- When any value is compared with `NULL`, the truth value is `UNKNOWN`

SQL Rules
- A query only produces a typle in the answer if its truth value for the `WHERE` clause is `TRUE` (not `FALSE` or `UNKNOWN`)

# `ORDER BY`: Sorting Results

```sql
SELECT PName, Price, Manufacturer
FROM Product
WHERE Category = 'Gadgets' AND Price < 50
ORDER BY Price, PName;
```

- Ordering is ascending unless you specify `DESC` keyword
    - `ORDER BY Price, PName DESC`
- Ties are broken by the second attribute on the `ORDER BY` list, etc.

## `NULL`s in `ORDER BY`

- `NULL` is normally treated as less than all non-null values

# Multi-Relation Queries

Sailors

| sid | sname | rating | age |
| --- | ----- | ------ | --- |
| 1   | Fred  | 7      | 22  |
| 2   | Jim   | 2      | 39  |
| 3   | Nancy | 8      | 27  |

Reserves

| sid | bid | bady |
| --- | --- | ---- |
| 1   | 102 | 9/12 |
| 2   | 102 | 9/13 |

```sql
SELECT S.sname
FROM Sailors S, Reserves R
WHERE S.sid = R.sid AND R.bid = 102;
```

# Subqueries

- Also called nested queries
- We can do nested queries because SQL is compositional
    - Everything (inputs/outputs) is represented as multisets - the output of one query can thus be used as the input to another (nesting)

## Types of Subqueries

- Scalar Subquery
    - Returns a single value which is then used in a comparison
    - If query expects a single value from a subquery and it returns multiple values or no values, a run-time error occurs
- Row Subquery
    - Returns a single row which may have multiple columns
- Table Subquery
    - Returns one or more columns and multiple rows 

### Scalar Subquery

E.g.: From `Sells(bar, beer, price)`, find the bars that serve Heineken for the same price `WOOBAR` charges for `Bud`

1. First, we find the price `WOOBAR` charges for `Bud`

```sql
SELECT price 
FROM Sells 
WHERE bar = 'WOOBAR' AND beer = 'Bud';
```

2. Find bars that serve Heineken for the same price

```sql
SELECT bar
FROM Sells
WHERE Sells.beer = 'Heineken' AND 
    Sells.price = (SELECT price 
                    FROM Sells 
                    WHERE bar = 'WOOBAR' AND beer = 'Bud');
```

### Row Subquery

Returns a single row which may have multiple columns
- Note that a single column with multiple rows is valid, as well as a single row with multiple columns

```sql
SELECT agent_name, agent_code, phone_no
FROM agents
WHERE agent_code = (
    SELECT agent_code 
    FROM agents
    WHERE agent_name = 'Alex'
);
```

#### Operators in Row Subquery

- `IN`
    - `<tuple> IN <relation>` is true if and only if the typle is a member of the relation

For example, if we had `Beers(name, manf)` and `Likes(drinker, beer)`, find the name and manufacturer of each beer that fred likes

```sql
SELECT name, manf
FROM beers
WHERE name IN(
    SELECT beer
    FROM Likes
    WHERE drinker = 'Fred'
)
```

- `ALL`
    - `x <> ALL(<relation>)` is true if and only if for every tuple `t` in the relation, `x` is not equal to `t`

From `Sells(bar, beer, price)`, find the beer(s) that sold for the highest price

```sql
SELECT beer
FROM Sells
WHERE price >= ALL (
    SELECT price
    FROM sells
)
```

- `ANY/SOME`
    - `x = SOME(<relation>)` is a boolean condition. Meaning that `x` **equals at least 1** tuple in the relation
    - Early version of SQL allowed `ANY`

From `Agents(agent_code, agent_name)`, `Customer(agent_code, cust_country)`, report all agents who belong to the country 'UK'

```sql
SELECT *
FROM Agents
WHERE agent_code = SOME(
    SELECT agent_code
    FROM Customer
    WHERE cust_country = 'UK'
)
```

### More Operators for Subquery

- Any of the comparison operators `<, <=, =`, etc.
- The keyword `NOT` can proceed any of the operators (`s NOT IN R`)

### Table Subquery

- Returns one or more columns and multiple rows

```sql
SELECT p1.name
FROM Product p1
WHERE p1.maker = 'Gizmo-Works'
AND EXISTS(
    SELECT *
    FROM Product p2
    WHERE p2.maker <> 'Gizmo-Works'
    AND p1.name = p2.name
);
```

This query select all products made by "Gizmo-Works" having the same names as products made by other companies

### Uncorrelated Subqueries

- A subquery is uncorrelated if the subquery is not related to the outer query

### Correlated Subqueries

- A subquery is correlated with the outer query if it contains a reference to an attribute in the outer query
- A subquery is correlated with the outside query if it must be re-computed for every typle produced by the outside query

```sql
SELECT p1.name
FROM Product p1
WHERE p1.maker = 'Gizmo-Works'
AND EXISTS(
    SELECT *
    FROM Product p2
    WHERE p2.maker <> 'Gizmo-Works'
    AND p1.name = p2.name
);
```

## Subquery: Rules to Remember

- The `ORDER BY` clause may not be used in a subquery
- The number of attributes in the `SELECT` clause in the subquery must match the number of attributes wiht the comparison operator
- Column names in a subquery refer to the table name in the `FROM` clause of the subquery by default
- When the result of a subquery is used as an opearnd, it must be the right operand

# Set Operations in SQL: `UNION`, `INTERSECT`, `EXCEPT`

These set operations are used to combine the results of 2 separate SQL queries

- Every subquery must have the same number of columns
- Columns must also have similar data types
- Columns in every subquery must be in the same order

## `UNION`

The `UNION` operator is used to combine the result-set of 2 or more `SELECT` statements. Similar to the $\cup$ operator.


```sql
SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
```

For example, consider the following relations:

- Likes(**drinker**, **beer**)
- Sells(**bar**, **beer**, price)
- Frequents(**drinker**, bar)

Find the drinkers and beers such that
1. The drinker likes the beer
2. The drinker frequents at least one bar that sells the beer

```sql
SELECT *
FROM Likes

UNION

SELECT drinker, beer
FROM Frequents, Sells
WHERE Frequents.bar = Sells.bar;
```

## `EXCEPT`

Similar to the $-$ operator. Returns records returned by `query1` that are not in `query2`

```sql
SELECT query1
EXCEPT
SELECT query2
```

## `INTERSECTS`

The SQL `INTERSECT` operator is used to return the results of 2 or more `SELECT` statements. It only returns the **rows selected by all queries** or data sets. If a record exists in one query and not in the other, it will be omitted from the `INTERSECT` results. Similar to the $\cap$ operator

```sql
SELECT column_name(s) FROM table1
INTERSECT
SELECT column_name(s) FROM table2;
```

For example, consider 2 tables

- Company(**name**, hq_city)
- Product(**pname**, maker, factory_loc)

If we want to find the headquarters of companies which make products in both US and China, we can use the following query

```sql
SELECT name, hq_city
INTO HQ_Name
FROM Company, Product
WHERE maker = name AND factory_loc = 'US'

INTERSECT

SELECT name, hq_city
FROM Company, Product
WHERE maker = name AND factory_loc = 'China';

SELECT DISTINCT hq_city
FROM HQ_Name;
``` 

Let us break down this query. First, we select all companies who have factory locations in US

```sql
SELECT name, hq_city
FROM Company, Product
WHERE maker = name AND factory_loc = 'US';
```

Then we select all companies who have factory locations in China

```sql
SELECT name, hq_city
FROM Company, Product
WHERE maker = name AND factory_loc = 'China';
```

We intersect both of them to find companies who have factories both in US and China. We place this into a new table called `HQ_Name` using `SELECT INTO`

```sql
SELECT name, hq_city
INTO HQ_Name
FROM Company, Product
WHERE maker = name AND factory_loc = 'US'

INTERSECT

SELECT name, hq_city
FROM Company, Product
WHERE maker = name AND factory_loc = 'China';
```

Note how we did the intersection on BOTH `name` and `hq_city`. If we only did an intersect on `hq_city`, it may be wrong. For example, company X with `hq_city` in Seattle has a `factory_loc` only in China, while company Y also with `hq_city` in Seattle has `factory_loc` only in US


Finally, we want only the `hq_city`s of the companies who have factories in both US and China, hence

```sql
SELECT DISTINCT hq_city
FROM HQ_Name;
```

However, if we are only allowed to use a single SQL query, we can make use of subqueries

```sql
SELECT DISTINCT hq_city
FROM (
    SELECT name, hq_city
    FROM Company, Product
    WHERE maker = name AND factory_loc = 'US'
    INTERSECT
    SELECT name, hq_city
    FROM Company, Product
    WHERE maker = name AND factory_loc = 'China'
);
```

## Bag Semantics vs. Set Semantics

- Set semantics: No duplicates, each item appears only once
- Bag semantics: Duplicates allowed, i.e. a multiset
- Default for `SELECT-FROM-WHERE` is bag
- Default for `UNION`, `INTERSECT`, and `EXCEPT` is set

To change the default semantics,
- We can force set semantics with `DISTINCT` after `SELECT`
- We can force bag semantics with `ALL` after `UNION`

For example

### `SELECT` vs `SELECT DISTINCT` (Bag vs Set semantics)

```sql
SELECT DISTINCT category FROM Product
```

| Category    |
| ----------- |
| Gadgets     |
| Household   |
| Photography |

```sql
SELECT category FROM Product
```

| Category    |
| ----------- |
| Gadgets     |
| Photography |
| Household   |
| Household   |
| Photography |

### `UNION` vs. `UNION ALL`

Consider the following table

Likes

| Drinker | Beer     |
| ------- | -------- |
| Sally   | Heineken |
| Sean    | Bud      |
| Melissa | Tiger    |

Buys

| Drinker | Beer     |
| ------- | -------- |
| Sally   | Heineken |
| Sally   | Bud      |
| Melissa | Heineken |
| Melissa | Tiger    |

If we did the following sql query:

```sql
SELECT * FROM Likes
UNION ALL
SELECT * FROM Buys;
```

We will get the following table:

| Drinker | Beer     |
| ------- | -------- |
| Sally   | Heineken |
| Sean    | Bud      |
| Melissa | Tiger    |
| Sally   | Heineken |
| Sally   | Bud      |
| Melissa | Heineken |
| Melissa | Tiger    |

Note how `(Sally, Heineken)` and `(Melissa, Tiger)` is repeated twice. However, if we were to use

```sql
SELECT * FROM Likes
UNION
SELECT * FROM Buys;
```

We would get

| Drinker | Beer     |
| ------- | -------- |
| Sally   | Heineken |
| Sean    | Bud      |
| Sally   | Bud      |
| Melissa | Heineken |
| Melissa | Tiger    |


# Joins

A `JOIN` is used to combine rows from 2 tables or more, based on a related column between them. These are the joins we will be looking at

- `INNER JOIN`
- `NATURAL JOIN`
- `LEFT [OUTER] JOIN`
- `RIGHT [OUTER] JOIN`
- `FULL [OUTER] JOIN`

Consider the following table

Orders

| OrderID | CustomerID | OrderDate  |
| ------- | ---------- | ---------- |
| 10308   | 2          | 1996-09-18 |
| 10309   | 1          | 1996-09-19 |

Customers

| CustomerID | CustomerName                       | ContactName    | Country |
| ---------- | ---------------------------------- | -------------- | ------- |
| 1          | Alfreds Futterkiste                | Maria Anders   | Germany |
| 2          | Ana Trujillo Emparedados y helados | Ana Trujillo   | Mexico  |
| 3          | Antonio Moreno Taquería            | Antonio Moreno | Mexico  |

## Inner Join

![](https://www.w3schools.com/sql/img_innerjoin.gif)

The $\bowtie$ operator. Returns records that have matching values in both tables. If the condition is not an equality, but an inequality, it is the $\bowtie_{\theta}$ (theta join) operator. The syntax is as follows

```sql
SELECT column_name(s)
FROM table1
INNER JOIN table2
ON table1.column_name = table2.column_name;
```

For example: Return the orderID, customer name and order date of all the orders

```sql
SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
```

| OrderID | CustomerName                       | OrderDate  |
| ------- | ---------------------------------- | ---------- |
| 10308   | Ana Trujillo Emparedados y helados | 1996-09-18 |
| 10309   | Alfreds Futterkiste                | 1996-09-19 |

## Natural Join

`NATURAL JOIN` joins 2 tables together on all column that has the same name between both tables. The syntax for a natural join is as follows:

```sql
SELECT ...
FROM Table1
NATURAL JOIN Table2;
```

The `INNER JOIN` equivalent for the query above is

```sql
SELECT ...
FROM Table1
INNER JOIN Table2
ON Table1.Column1 = Table2.Column2;
```

Unlike `INNER JOIN`, `NATURAL JOIN` does not specify the columns. If `TableA` and `TableB` share multiple columns with the same name, all the column values must match

```sql
SELECT ...
FROM Table1
JOIN Table2
ON Table1.Column1 = Table2.Column1 AND Table1.Column2 = Table2.Column2;
```

Consider the following 2 tables

```
TableA                           TableB
+------------+----------+        +--------------------+    
|Column1     | Column2  |        |Column1  |  Column3 |
+-----------------------+        +--------------------+
| 1          |  2       |        | 1       |   3      |
+------------+----------+        +---------+----------+
```

The `INNER JOIN` of `TableA` and `TableB` on `Column1` will return

```sql
SELECT * FROM TableA AS a INNER JOIN TableB AS b ON TableA.Column1 = TableB.Column1; // Equivalently,
SELECT * FROM TableA AS a INNER JOIN TableB AS b USING Column1;
```

```
+------------+-----------+---------------------+    
| a.Column1  | a.Column2 | b.Column1| b.Column3|
+------------------------+---------------------+
| 1          |  2        | 1        |   3      |
+------------+-----------+----------+----------+
```

However, using `NATURAL JOIN` the query will return

```sql
SELECT * FROM TableA AS a NATURAL JOIN TableB AS b;
```

```
+------------+----------+----------+    
|Column1     | Column2  | Column3  |
+-----------------------+----------+
| 1          |  2       |   3      |
+------------+----------+----------+
```

The repeated column is avoided

## Left (Outer) Join

![](https://www.w3schools.com/sql/img_leftjoin.gif)

The $\mathring{\bowtie}_L$ operator. Returns all records on the left table, and matched records from the right table. Unmatched records on the right table will be `NULL`. The syntax is as follows

```sql
SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name = table2.column_name;
```

You can also optionally include the keyword `OUTER` in it, as it is optional. It is the same thing

```sql
SELECT ...
FROM table
LEFT OUTER JOIN table2
ON ...;
```

```sql
SELECT Customers.CustomerName, Orders.OrderID, Orders.OrderDate
FROM Customers
LEFT JOIN Orders
ON Customers.CustomerID=Orders.CustomerID
ORDER BY Customers.CustomerName;
```

| CustomerName                       | OrderID | OrderDate  |
| ---------------------------------- | ------- | ---------- |
| Alfreds Futterkiste                | 10309   | 1996-09-18 |
| Ana Trujillo Emparedados y helados | 10308   | 1996-09-18 |
| Antonio Moreno Taquería            | null    | null       |

## Right (Outer) Join

![](https://www.w3schools.com/sql/img_rightjoin.gif)

`RIGHT JOIN` returns all records from the right table (table2), and the matching records from the left table (table1). Similar to the $\mathring{\bowtie}_R$ operator.

```sql
SELECT column_name(s)
FROM table1
RIGHT JOIN table2
ON table1.column_name = table2.column_name;
```

You can also optionally include the keyword `OUTER` in it, as it is optional. It is the same thing

```sql
SELECT ...
FROM table
RIGHT OUTER JOIN table2
ON ...;
```

## Full Outer Join

![](https://www.w3schools.com/sql/img_fulljoin.gif)

Similar to the $\mathring{\bowtie}$ operator. The `FULL OUTER JOIN` or `FULL JOIN` keyword returns all matching records from both tables whether the other table matches or not. So, if there are rows in `table1` that do not have matches in `table2`, or if there are rows in `table2` that do not have matches in `table1`, those rows will be listed as well.

```sql
SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2
ON table1.column_name = table2.column_name
WHERE condition;
```

## Join Semantics

```sql
SELECT R.A
FROM R, S
WHERE R.A = S.B;
```

The above is equivalent to 

```sql
SELECT R.A
FROM R
INNER JOIN S
ON R.A = S.B;
```

A join is simply a 
1. Cross product of the 2 tables, then a 
2. Filter on the condition (the `ON` condition)
3. Project on the columns

(This is not exactly how a DBMS executes a join under the hood)

## `INNER JOIN USING` vs `INNER JOIN ON`

```sql
SELECT * FROM R
INNER JOIN S
USING <attribute-list>;

SELECT * FROM R
INNER JOIN S
ON R.column_name = S.column_name;
```

- `USING` is useful when both tables share a column of the exact same name on which they join. For example

    ```sql
    SELECT ... FROM film JOIN film_actor USING (film_id) WHERE ...;
    ```

- `ON` is more flexible than `USING` because it allows any valid boolean expression. To get the same query as above using `ON`:

    ```sql
    SELECT ... FROM film JOIN film_actor ON (film.film_id = film_actor.film_id) WHERE ...;
    ```

    We can also use any other boolean expression

    ```sql
    SELECT ... FROM Managers JOIN Employees ON (Mangers.ID = Employees.ManagerID AND Employees.salary > Mangers.salary);
    ```

## More Examples for Joins

1. Consider the following tables

    - Product(**PName**, Price, Category, Manufacturer)
    - Company(**CName**, StockPrice, Country)

    Find all countries that manufacture some products in the "Gadgets" category

    ```sql
    SELECT DISTINCT Country
    FROM Product
    INNER JOIN Company
    WHERE Product.Manufacturer = Company.CName; AND Product.Category = 'Gadgets';
    ```

    Note the use of `DISTINCT`, because the inner join has bag semantics, hence duplicates will not be removed. Since we only want the countries that manufacture some products in the "Gadgets" category, we should use `DISTINCT` to remove the duplicates

2. Consider the following SQL statement

    ```sql
    SELECT R.A
    FROM R, S, T
    WHERE R.A = S.A OR R.A = T.A;
    ```

    If `S` is an empty table, what is the output of the query above?

    Recall the semantics of the join
    1. Take cross product of `R`, `S`, `T`
    2. Apply selections/conditions
    3. Apply projection

    If `S` is empty, then the cross product of `R`, `S`, `T` is empty, and hence the query result is also empty

# Aggregation

Aggregate functions perform a calculation over a set of values. Examples of aggregate functions in SQL include:

- `COUNT` counts how many rows are in a particular column
- `SUM` adds together all the values in a particular column
- `MIN` and `MAX` return the lowest and highest values in a particular column respectivelyl
- `AVG` calculates the average of a group of selected values

Note: Except `COUNT`, all aggregations apply only to a single attribute (column)

For example,

```sql
SELECT AVG(Price)
FROM Product
WHERE maker = 'Toyota';
```

This returns the average price of all products made by Toyota

```sql
SELECT COUNT(*)
FROM Product
WHERE year > 1997;
```

This returns the number of products which were created after 1997

## Some rules regarding aggregate functions

- Counts the number of rows for a particular column. Note that `COUNT` **applies to duplicates** unless otherwise stated

    ```sql
    SELECT COUNT(category)
    FROM Product
    WHERE year > 1996;
    ```

    vs

    ```sql
    SELECT COUNT(DISTINCT category)
    FROM Product
    WHERE year > 1996;
    ```

- `COUNT`, `MAX`, `MIN` can apply to all types of fields (string, boolean, numeric etc.)
- `SUM` and `AVG` only apply to numeric fields
- Other than `COUNT(*)`, all functions ignore nulls
    - Consider the table Beer(beer, manufacturer)
    - `SELECT COUNT(manufacturer) FROM Beer` will
        - Ignore `NULL` manufacturers
        - Duplicate manufacturers will be counted

    - `SELECT COUNT(*) FROM Beer` will
        - Count `NULL` manufacturers
        - Count duplicate manufacturers

    - `SELECT COUNT(DISTINCT manufacturer) FROM Beer`
        - Counts the number of distinct manufacturers
        - Nulls are ignored
        - This is the same as 

        ```sql
        SELECT INTO Beer_Manufacturers DISTINCT manufacturer FROM Beer; // gets distinct, not-null manufacturers
        SELECT COUNT(manufacturer) FROM Beer_Manufacturers; // counts the number of rows returned by previous query
        ```

    - `SELECT DISTINCT COUNT(manufacturer) FROM Beer`
        - Counts the number of not-null manufacturers (including duplicates)
        - Nulls are ignored
        - This is the same as

        ```sql
        SELECT INTO Beer_Manufacturers COUNT(manufacturer) FROM Beer; // ignores null, counts duplicates
        SELECT DISTINCT Beer_Manufacturers; // since previous query returns only 1 row, DISTINCT does nothing
        ```
- `COUNT(*)` returns the number of rows in the table
- Use `DISTINCT` to eliminate duplicates


# `EXISTS`

The `EXISTS` operator is used to test for the existence of any record in a subquery. The `EXISTS` operator returns `TRUE` if the subquery returns one or more records.

```sql
SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);
```

# Resources

- https://www.w3resource.com/sql/subqueries/single-row-subqueries.php
- https://www.w3schools.com/sql/sql_join_left.asp
- https://www.w3schools.com/sql/sql_join_inner.asp
- https://www.w3schools.com/sql/sql_join_right.asp
- https://www.w3schools.com/sql/sql_union.asp
- https://mode.com/sql-tutorial/sql-aggregate-functions/
- https://stackoverflow.com/questions/33589606/select-distinct-countid-vs-select-countdistinct-id
- https://stackoverflow.com/questions/11366006/mysql-join-on-vs-using




